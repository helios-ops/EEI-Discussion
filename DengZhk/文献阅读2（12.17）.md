北京邮电大学学报 2016年6月

基于动态符号执行的C代码缓冲区溢出检测

张俊贤， 李舟军

以C程序源码中的缓冲区溢出漏洞为目标，提出了一个基于底层虚拟机中间代码的漏洞检测工具PathChecker。该工具基于动态符号执行方法，使用无量词谓词公式刻画缓冲区操作的安全性质，并利用可满足模型理论求解器技术检验缓冲区操作的安全性。

1 问题与方法概述

简述了缓冲区溢出的原理，介绍了动态符号执行的两个特点：一是符号执行和具体执行同时进行;
二是交替使用静态分析和动态分析．
动态符号执行是动态与静态分析技术的结合，它融合了两种执行方式，在具体执行的同时对执行到的指令进行符号化执行。

**方法简述**：针对C程序的复杂数据类型变量进行分解，得到一系列简单类型变量，并将其标注为符号变量，在该简单类型变量的粒度上，基于动态符号执行方法获取程序执行路径的约束；该方法使用深度优先搜索算法遍历程序的路径，在每条程序路径上使用无量词谓词公式捕获程序的操作语义，刻画缓冲区操作的安全性质，并使用SMT求解器检验缓冲区操作的安全性，以推断是否存在缓冲区溢出可能；

**研究成果**：提出一个缓冲区溢出检测工具PathChecker。该工具对动态符号执行工具PathWalker进行扩展，在每次执行过程中沿着当前的执行路径进行符号化执行，并不断更新符号状态，若遇到一条缓冲区访问操作指令，则使用SMT求解器检验在当前符号状态下该操作是否一定满足安全性质。

2 基于动态符号执行检测缓冲区溢出

PathWalker基于类型分解的方法，将复杂类型变量打散为简单类型变量集合，在类型结构的各层上标注和管理符号变量集合，在基本类型的粒度上实现符号执行。

![](media/dd2799f1422920902a57fe68fc5d2226.png)

2.1 PathChecker 整体框架

**静态分析阶段**

1.首先使用LLVM编译架构提供的C语言编译前端Clang将C代码编译为LLVM中间代码。

2.在此基础上抽取程序变量的类型及其他静态信息，并自动化生成测试驱动代码，测试驱动代码本身是一个可以被编译和执行的C++程序。

3.之后，对LLVM中间代码进行程序插桩处理，针对LLVM指令插入相对应的函数调用指令，在这些函数调用中实现符号执行逻辑。

4.最后对插桩得到的LLVM中间代码编译和链接，得到可以实际执行的程序。

**动态分析阶段**

1.首先结合模糊测试，产生随机输入数据，并实际运行待分析程序，在每次执行过程中PathChecker沿着当前的执行路径进行符号化执行，并不断更新符号状态。

2.在此过程中，若遇到一条缓冲区访问操作指令，则使用SMT求解器检验在当前符号状态下该操作是否一定满足安全性质。

3.符号执行引擎在执行的过程中不断收集路径约束，每次执行结束后，使用深度优先搜索算法对路径约束集合末尾的约束进行取反，以得到一组新的约束。

4.迭代整个过程，直到所有路径分析完毕或者提前设置好的运行时间用尽。

2.2 符号变量管理

**全 局 变 量**：将全部全局变量放置于一张哈希表中

>   **局部和参数变量**：为函数调用堆栈中的每个函数分别维护一张哈希表，以放置其符号变量

2.3 循环展开控制

在静态分析阶段确定程序中的循环结构，并使用控制流分析确定输入参数是否为某循环结构的控制变量，若是，则为其设置一个上限阈值以控制其展开的遍数，此阈值默认为5

2.4 函数调用的处理

用户定义函数：PathChecker以*符号化函数*调用模拟实际函数调用。

第三方函数：误报和漏报有可能发生，对于此点，笔者*尚无较好处理方法*。

标准库函数：选取其中常用部分函数，对其实现代码进行*插桩处理*，得到它们的符号化执行版本，以代替标准C库函数的调用。

2.5 缓冲区溢出检测

假定某一数组上下界变量分别为lb和hb，其索引变量为i，其中lb通常为0，hb可以为固定值(静态声明数组)，或者为程序变量(
动态创建数组)，对应的符号变量分别为LB、HB和I。

在当前符号状态下对其分别进行求值，并得到符号表达式LBE、HBE和IE，则安全性质表达式为:LBE＜IE＜HBE。

最后，向求解器询问，是否存在一组输入使IE＜LBE或IE＞HBE成立?
若存在这种输入，使用它执行程序则在此处会发生数组越界访问错误，若随后执行的是写入内存指令，则缓冲区可能溢出。

在LLVM中间语言代码中，GEP指令总是处于实际访存指令load和store之前。因此，使用程序插桩技术对GEP指令的执行进行观察、记录和分析，以实现对缓冲区溢出的检测。

在静态分析阶段确定被分析程序中的哪条GEP指令之后跟随着store指令，然后在这两条指令之间插入一条函数调用指令，插桩器将GEP指令的每个参数(具体值)及其所对应的符号变量ID作为参数传入此函数调用指令

3 系统实现与实验评估

工具名称：PathChecker

开发环境：visual studio 2008，C++语言

求解器：Z3 求解器

试验平台配置：Intel Core 2 Duo 2.40GHz CPU，3GB 内存，WinXP系统

系统模块（4个）:符号化的C标准库、程序插桩器、测试驱动代码生成器、符号执行引擎。

![](media/8f6132e982c4babcdae2533a9f788429.png)

![](media/435dc36ed25c52c1059a25e1bf805365.png)

在有的情况下不能覆盖全部分支，原因主要有两方面:

一是路径约束有时过于复杂，超出了求解器的能力范围;

二是原型系统对函数调用的支持尚不够充分。

4 结束语

| 1 | 现阶段问题     | 约束的求解是该方法的效能和效率瓶颈。                                                                                        |
|---|----------------|-----------------------------------------------------------------------------------------------------------------------------|
|   | 下一步研究方向 | 通过对约束进行优化，并利用并行计算能力缓解此瓶颈。                                                                          |
| 2 | 现阶段问题     | 对C标准库的符号化执行并不完整，而且也没有对环境交互部分进行建模，如文件和socket访问等，这极大地限定了该原型工具的适用范围。 |
|   | 下一步研究方向 | 为该工具提供更加完整的环境模拟能力是未来工作的另一重点。                                                                    |
